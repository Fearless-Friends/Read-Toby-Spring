# 목차    
- [7. 스프링 핵심 기술의 응용](7.-스프링-핵심-기술의-응용)
    - [7.1 SQL과 DAO의 분리](7.1-SQL과-DAO의-분리)
    - [7.2 인터페이스의 분리와 자기참조 빈](7.2-인터페이스의-분리와-자기참조-빈)
    - [7.3 서비스 추상화 적용](7.3-서비스-추상화-적용)
    - [7.4 인터페이스 상속을 통한 안전한 기능확장](7.4-인터페이스-상속을-통한-안전한-기능확장)


<BR>

## **7. 스프링 핵심 기술의 응용**
스프링의 3대 핵심 기술
- DI/IoC
- 서비스 추상화
- AOP

위 기술들을 애플리케이션 개발에 이용해보도록 하자.

<BR>

## **7.1 SQL과 DAO의 분리**
DAO 코드 내부에 SQL 쿼리가 있을 때 다음과 같은 위험이 있다.
- DB 테이블, 필드 명, SQL 변경시 DAO 소스코드가 변경됨
- 같은 필드, 테이블을 여러 곳에서 레퍼런스 하는 경우 수정시 휴먼 에러 발생 가능 
- DAO의 관리와 SQL의 관리가 같은 오브젝트에서 일어남

이 문제를 해결하기 위해 쿼리를 아래와 같이 Bean 설정을 담은 XML에 Query 정보를 입력하는 형태로 수정이 가능하다.     


```xml
<bean ... >
    <property name="sqlAdd", value ="insert into users(id, name, password, email, level, login, recommend) values(?, ?, ?, ?, ?, ?, ?)" />
    ...
```

하지만 위 방법은 좀 불편하다.      
매번 새로운 SQL을 만들 때마다 프로퍼티를 추가하고, DI를 위한 변수와 set 함수도 만들어야 한다.       

<BR>

### **SQL Map Property**        
위 방법은 너무 불편하니, SQL을 하나의 Collection으로 담아두도록 해보자.     
Map을 이용하면 Key를 이용해 SQL 문장을 가져올 수 있다.      

```java
public class UserDaoJdbc implements UserDao {
    ...
    private Map<String, String> sqlMap;

    public void setSqlMap(Map<String, String> sqlMap) {...};
    ...
}

// 적용
public void add(User user) {
    this.jdbcTemplate.update(
        this.sqlMap.get("add"),
        ...
    )
}
```
위와 같은 형태로 수정이 가능하다.       
이를 위해 XML도 아래와 같은 형태로 수정되어야 한다.

```xml
<property name="sqlMap">
    <map>
        <entry key="sqlAdd", value ="insert into users(id, name, password, email, level, login, recommend) values(?, ?, ?, ?, ?, ?, ?)" />
        ...
    </map>
<property>
```
이제 Entry만 추가하면 자유롭게 Query를 가져다 쓸 수 있게 되었다.

<BR>

### **SQL Service의 분리**
또 다른 문제로는 Bean 설정과 SQL 설정을 하나의 XML에서 수행하는것은 관리하기 어렵다는 것이 있다.            
그렇기에 쿼리를 가져오는 작업을 SQL Service로 분리하도록 하자.      
```java
public interface SqlService {
    String getSql(String key) throws SqlRetrievalFailureException;
}

public class UserDaoJdbc implements UserDao {
    ...
    private SqlService sqlService;
    public void setSqlService(SqlService sqlService) {...}; 
    ...
}

// 적용
public void add(User user) {
    this.jdbcTemplate.update(
        this.sqlServie.getSql("userAdd"),
        ...
    )
}
```

## **7.2 인터페이스의 분리와 자기참조 빈**
위 인터페이스의 구현 방법에 대해 고민해보자.        

그 전에, 현재 스프링 XML 파일에서 <bean> 태그 내부에 SQL 정보까지 들어있는 것은 좋은 방법이 아니다.     
SQL을 저장하는 독립적인 파일을 이용하는 것이 바람직하다.        

<BR>

### **JAXB (Java Architecture for XML Binding)**
XML에 담긴 정보를 읽어오는 방법 중 하나이다.        
DOM과 같은 전통적인 XML API와 비교하여, XML 정보를 거의 동일한 구조의 오브젝트로 매핑해준다는 장점이 있다.      

이를 이용해 XML에 SQL의 정보를 별도로 저장하고, 이를 이용한 XmlSqlService를 구현 방법으로 고민해볼 수 있다.         

<BR>

### **인터페이스 분리**
위 논리대로 인터페이스를 설계한다면, XmlSqlService 한계에 직면하게 된다.        
SQL을 가져오는 방법이 특정 기술에 고정되어 있다. 만약 XML 대신 다른 방법으로 가져와야한다면 전체 구조를 변경해야 할 것이다.     
이에 SQL을 읽어오는 부분인 SqlReader와 SQL 등록 & 조회를 수행하는 SqlRegistry로 구분한다.       

```java
public interface SqlRegistry {
    void registerSql(String key, String sql);
    String findSql(String key) throws SqlNotFoundException;
}

public interface SqlReader {
    void read(SqlRegistry sqlRegistry);
}
```

이렇게 분리된 작업을 XmlSqlService에 적용하면 다음과 같은 형태가 된다.
```java
public Class XmlSqlService implements SqlService, SqlRegistry, SqlReader {
    private SqlReader sqlReader;
    private SqlRegistry sqlRegistry;
    ...
}
```

이제 Bean 설정을 통해 실제 DI가 일어나도록 해야한다.        
클래스는 하나 뿐이고, Bean도 하나만 등록하지만 마치 3개의 Bean이 등록된 것처럼 SqlService Bean이 SqlRegistry와 SqlReader를 주입받도록 만들어야 한다.        

```xml
<bean id="SqlService" ...>
    <property name="sqlReader" ref="sqlService" />
    <property name="sqlRegistry" ref="sqlService" />
    ...
</bean>
```

이제 책임과 관심사가 복잡하게 얽혀있던 구조를, 책임 단위로 구분할 수 있게 되었다.       
당장 구현을 바꿔서 사용하지 않더라도, 언제든지 확장에 자유로운 구조가 되었다. 

<BR>

## **7.3 서비스 추상화 적용**
XML과 JAVA Object를 Mapping 해서 상호변환 해주는 기술을 OXM(Object XML Mapping)이라고 한다.     
OXM 프레임워크와 기술들은 JAXB를 포함해서 다른 여러 기술들 모두 사용 목적이 동일하기 때문에 유사한 기능과 API를 제공한다.       

> 기능이 같은 여러가지 기술이 존재 -> 서비스 추상화 가능      

Low level 기술과 API에 종속되지 않고,  추상화된 레이어와 API를 제공해서 구현 기술에 대해 독립적인 코드를 작성할 수 있게 위 구조를 변경해보자.       

- **Marshaller** : Java Object -> XML     
- **UnMarshaller** : XML -> Java Object

UnMarshaller 인터페이스를 이용하여 추상화를 진행해보자.
```java
public interface Unmarshaller {
    boolean supports(Class<?> class); // 해당 클래스로 언마샬이 가능한지 체크
    Object unmarshal(Source source); // source를 통해 제공받은 XML을 JAVA Object Tree로 변환해서 root Object를 return
}
```

위 인터페이스에 JAXB 언마샬러를 등록한 Bean을 만들어서 이용하면 끝이다.
```xml
<bean id="unmarshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
    <property name="contextPath" value="springbook.user.sqlservice.jaxb" />
</bean>
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration // 클래스 이름 + context.xml 파일을 사용하는 애플리케이션 컨텍스트로 만들어서 테스트 시 사용가능
public class OxmTest {
    @Autowired
    Unmarshaller unmarshaller;

    @Test
    public void unmarshallSqlMap() throws XmlMappingException IOException {
        SourcexmlSource = new StreamSource(getClass().getResourceAsStream("sqlmap.xml")); 

        Sqlmap sqlmap = (Sqlmap) this.unmarshaller.unmarshal(xmlSource); // 이거면 끝
        ...
    }
}
```
이제 코드 어디에도 JAXB 기술을 구체적으로 이용한다는 부분은 없다.       
따라서 기술을 변경하여도 XML만 수정하면 된다.       

이제 이 추상화된 OXM 기능을 SqlService에 적용해보자.

```java
public class OxmSqlService implements SqlService {
    private final OxmSqlReader oxmSqlReader = new OxmSqlReader(); // unmarshaller을 필드로 갖고 있음, final 키워드로 유일 객체 보장
    ...

    private class OxmSqlReader implements SqlReader {
        ... // 내부에서 단독참조 가능
    }
}
```
위 형태로 구현이 되면, SqlService를 DI하는 파라미터를 통해 SqlReader도 DI가 가능하게 된다.

SqlService Bean 설정만으로 구현 가능한 상태가 되는 것이다.

위 내용을 구현하면 아래와 같다.

```java
public class OxmSqlService implements SqlService {
    private final OxmSqlReader oxmSqlReader = new OxmSqlReader();
    ...

    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.oxmSqlReader.setUnmarshaller(unmarshaller); // 전달만
    }

    public void setSqlmapFile(String sqlmapFile) {
        this.oxmSqlReader.setSqlmapFile(sqlmapFile);
    }

    @Setter
    private class OxmSqlReader implements SqlReader {
        private Unmarshaller unmarshaller;
        private String sqlmapFile;
        ...
    }

    @PostConstruct
    public void loadSql() {this.oxmSqlReader.read(this.sqlRegistry);}

    public String getSql(String key) throws SqlRetrievalFailureException {
        try { return this.sqlRegistry.findSql(key) }
        catch(SqlNotFoundException e) { throw new SqlRetrievalFailureException(e); }
    }
}
```
이제 SqlService와 Unmarshaller Bean만을 관리해서        
의도하지 않은 방식으로 확장될 위험 없이 이용할 수 있게 되었다.

그런데, loadSql과 getSql을 보면, BaseSqlServiec와 중복되는 부분이 생기게 된다.      
무시할 수준이긴 하지만, 코드의 양이 늘어날 경우를 고려하여 설계해보자.      

baseSqlService 또한 OxmSqlReader와 비슷하게 참조해서 사용해보자.        
SqlService의 구현부를 BaseSqlService에 위임하는 형태가 될 것이다.

```java
public class OxmSqlService implements SqlService {
    private final BaseSqlService baseSqlService = new BaseSqlService();
    ...

    @PostConstruct
    public void loadSql() {        
        this.baseSqlService.setSqlRegistry(this.sqlRegistry);
        this.baseSqlService.setSqlReader(this.oxmSqlReader);
    }

    public String getSql(String key) throws SqlRetrievalFailureException {
        try { return this.sqlRegistry.findSql(key) }
        catch(SqlNotFoundException e) { throw new SqlRetrievalFailureException(e); }
    }
}
```

OXM 추상화를 위한 한 단계는 마무리했다.

<BR>

### **리소스 추상화**
SQL Mapping 정보가 담긴 XML을 현재는 클래스패스에 존재하는 것만 사용할 수 있지만, XML을 읽어낼 수 있는 현재 파일의 경로에 제한될 필요는 없다.       

추상화 과정을 통해 여러 종류의 리소스를 불러오는 방법을 알아보자.       
먼저, JAVA에 존재하는 리소스 접근 API를 추상화해서 Resource라는 추상화 인터페이스를 정의했다.       
하지만 이는 Bean이 아니고 값의 일종이므로, 자유로운 추상화가 불가능하다.        

<BR>

### **리소스 로더**
스프링에는 접두어를 토대로 리소스 오브젝트를 선언하는 리소스 로더가 존재한다.       
스프링의 ApplicationContext가 대표적인 리소스 로더이다.     
이를 통해 리소스를 불러오고, Resource 오브젝트로 생성해보도록 하자.     

```java
...
public void setSqlmap(Resource sqlmap) {
    this.oxmSqlReader.setSqlmap(sqlmap); // 타입을 변경하자
}
..
```

위 형태로 변경하고, Resource를 DI 받아보자.
```xml
<bean id="sqlService" class="springbook.user.sqlservice.OxmSqlService"> 
    ...
    <property name="sqlmap" value="classpath:springbook/user/dao/sqlmap.xml">
</bean>
```
이렇게 Resource를 생성한다고 해서 Resource 오브젝트가 실제 리소스는 아니라는 점을 주의해야한다.         
Resource는 단지 리소스에 접근할 수 있는 추상화된 핸들러일 뿐이다.

classpath:는 클래스 패스를 기준으로 상대경로를 지정하는 것이고,     
파일 시스템을 기준으로 가져온다면 루트 경로를 file:을 통해 지정할 수 있다.      
웹상의 리소스를 가져와야한다면 http://www.blah.xml 도 가능하다.     

<BR>

## **7.4 인터페이스 상속을 통한 안전한 기능확장**
만약에, 운영서버를 멈추지 않고 SQL의 내용을 변경해야하는 상황이 온다면 어떻게 해야할까?         

이에 대해 고민해보기 전에, DI에 대해 생각해보자.       
DI를 DI답게 만들려면, 두 개의 오브젝트가 인터페이스를 통해 느슨하게 연결되어 있어야 한다.       

오브젝트가 응집도 높은 작은 단위로 설계 되었더라도, 목적과 관심이 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있다.        
이를 인터페이스 분리 원칙이라고 한다.       

SqlService의 기본 구현인 BaseSqlService의 클래스 구조를 보면, BaseSqlService와 그 서브클래스인 SqlReader, SqlRegistry라는 두개의 인터페이스를 통해 DI받고 있기 때문에, MySqlRegistry의 구현 내용의 변경이 있더라도 BaseSqlService는 변경 없이 유지될 수 있는 것이다.            

<BR>

### **인터페이스 상속**
다시 문제의 본질로 돌아가면, 실제 SQL을 등록하고, SQL을 다시 검색해오는 SqlRegistry에 기능을 추가하여 업데이트가 가능하도록 기능을 추가할 수도 있을것이다.      
하지만, BaseSqlService에서는 등록과 검색이 아닌 확장 기능은 제공하고 싶지 않다.     
이럴 땐 인터페이스의 상속을 이용할 수 있다.

수정 기능을 가진 확장 인터페이스를 아래와 같이 설계하고, 이를 SqlAdminService에서 구현하도록 해보자.

```java
public interface UpdatableSqlRegistry extends SqlRegistry {
    public void updateSql(String key, String sql) throws SqlUpdateFailureException;
    public void updateSql(Map<String, String> sqlMap) throws SqlUpdateFailureException;
}
```

인터페이스의 상속을 통해 SqlRegistry의 기능은 그대로 가지고 있지만, 업데이트의 기능을 추가로 가지고 있는 Registry interface를 설계했다.         

이렇게 되면 아래와 같이 SqlRegistry Bean을 참고하면서도 다양하게 DI를 수행할 수 있다.        

```xml
<bean id="sqlService" class="springbook.user.sqlservice.BaseSqlService">
    ...
    <property name="sqlRegistry" ref="sqlRegistry" />
</bean>

<bean id="sqlRegistry" class="springbook.user.sqlservice.MyUpdatableSqlRegistry" />

<bean id="sqlAdminService" class="springbook.user.sqlservice.SqlAdminService">
    ...
    <property name="updatableSqlRegistry" ref="sqlRegistry" /> <!-- 동일 참조 -->
</bean>
```

위처럼 Bean을 정의하고, 실제 코드는 아래와 같이 사용할 수 있다.

```java
public class SqlAdminService implements AdminEventListener {
    private UpdatableSqlRegistry updatableSqlRegistry;

    public setUpdatableSqlRegistry(UpdatableSqlRegistry updatableSqlRegistry) {...};

    public void updateEventListener(UpdateEvent event) {
        this.updateSqlRegistry.updateSql(event.get(KEY_ID), event.get(SQL_ID));
    }
}
```

<BR>

## **7.5 DI를 이용해 다양한 구현 방법 적용하기**
운영중인 시스템에서 사용하는 정보를 실시간으로 변경하는 작업을 만들 때 가장 먼저 고려해야할 사항은 동시성 문제다.       
한 번 초기화하고, 그 뒤에는 읽기 전용으로 동작하는 SqlRegistry의 방식에서는 위 문제가 발생할 일이 없지만, 수정은 다르다.     

<BR>

2가지 방법을 통해 동시성 이슈를 해결할 수 있다.
- ConcurrentHashMap
- 내장형 DB

<BR>

### **ConcurrentHashMap**
동시성 이슈를 해결하기 위한 방법으로 ConcurrentHashMap을 이용할 수 있다.        
데이터 조작시 전체 데이터에 대해 락을 걸지 않고, 조회는 락을 아예 사용하지 않는다.  

아래와 같은 형태로 적용할 수 있다.
```java
public class ConcurrentHashMapSqlRegistry implements UpdatableSqlRegistry {
    
    private Map<String, String> sqlMap = new ConcurrentHashMap<String, String>();
    
    public String findSql(String key) throwsSqlNotFoundException{
        ...
    }

    public void registerSql(String key, String sql) { sqlMap.put(key, sql) }

    public void updateSql(String key, String sql) throws SqlUpdateFailureException {
        ...
    }

    public void updateSql(Map<String, String> sqlmap) throws SqlUpdateFailureException {
        ...
    }
}
```


<BR>

### **내장형 DB**
서버가 떠있는 동안만 사용할 수 있는 DB로 데이터를 메모리에 저장한다.        
디스크가 아닌 메모리에 데이터를 저장하므로 성능이 뛰어나며, Collection이나 Object에 데이터를 저장하는 것보다 효과적이고 안정적인 형태로 데이터를 저장할 수 있다.        
lock, Transaction isolation level 등을 적용할 수 있다는 특징이 있다.              

스프링에서 제공하는 내장형 DB로는 Derby, HSQL, H2 등이 있는데, 모두 JDBC 드라이버를 적용할 수 있고, DataSource의 사용 방법을 그대로 이용하는 EmbeddedDatabaseBuilder를 사용할 수 있다.      

```java
public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry {
    SimpleJdbcTemplate jdbc;

    public void setDataSource(DataSource dataSource) {
        jdbc = new SimpleJdbcTemplate(datasource);
    }

    ...
}
```
이런 형태로 DataSource를 통해 EmbeddedDatabase를 주입받을 수 있다.

<BR>

### **테스트 코드의 중복**
UpdatableSqlRegistry interface의 경우 ConcurrentHashMap과 EmbeddedDb 방식 모두에게 적용되어 있다.       
오버라이딩한 메소드를 각각 모두 테스트한다면, 테스트코드가 중복될 것이다.       

이를 아래와 같은 구조로 해결할 수 있다.

```java
public class ConcurrentHashMapSqlRegistryTest extends AbstractUpdatableSqlRegistryTest {
    UpdatableSqlRegistry sqlRegistry;

    @Before
    public void setUp() {
        sqlRegistry = new ConcurrentHashMapSqlRegistry();
    }

    ...
}
```
사용하는 SqlRegistry를 연결해주는 부분만 독립적으로 설계하고, 공통된 테스트코드는 AbstractUpdatableSqlRegistryTest의 테스트 코드를 이용하면 된다.       

<BR>

### **내장형 DB에 트랜잭션 적용하기**
내장형 DB를 적용했으므로, 이제 SQL을 보다 자유롭게 변경할 수 있게 되었다.       

만약, 동시에 여러 SQL을 수정하는 상황이 온다면 어떻게 해야할까?         
하나의 SQL을 수정하게 되는 상황에서, 그것과 연관된 다른 SQL을 수행해야 하는 상황일 것이다.      
그러나, 위 코드로 이 작업을 수행하게 됐을 때, 중간에 작업을 실패한다면 중간에 실행된 부분까지만 SQL 변경이 적용되는 불상사가 발생할 수 있다.        

위 문제를 해결하기 위해 내장형 DB에 트랜잭션을 적용해보자.

<BR>

스프링에서 트랜잭션을 적용할 때 **트랜잭션 경계가 DAO 밖에 있고, 범위가 넓은 경우**라면 **AOP를 이용하는 것이 편리**하다.       
하지만 SQL 레지스트리라는 **제한된 오브젝트 내에서 서비스에 특화된 간단한 트랜잭션이 필요한 경우**라면 AOP와 같이 거창한 방법 보다는 간단히 **트랜잭션 추상화 API를 직접 사용하는 것이 더 편리**할 것이다.

<BR>

일반적으로는 트랜잭션 매니저를 싱글톤 빈으로 등록해서 사용해야 한다.        
여러 개의 AOP를 통해 만들어지는 트랜잭션 프록시가 같은 트랜잭션 매니저를 공유해야 하기 때문이다.        
그러나 EmbeddedDbSqlRegistry가 사용할 TransactionTemplate은 트랜잭션 매니저를 공유할 필요가 없다.       
따라서 Bean으로 등록하지 말고, 인스턴스에 직접 만들어서 사용하도록 하자.        

아래와 같은 형태로 구현할 수 있다.
```java
public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry {
    SimpleJdbcTemplate jdbc;
    TransactionTemplate transactionTemplate;

    public void setDataSource(DataSource dataSource) {
        jdbc = new SimpleJdbcTemplate(datasource);
        transactionTemplate = new TransactionTemplate(
            new DataSourceTransactionManager(datasource));
    }

    ...

    public void updateSql(final Map<String, String> sqlmap) throws SqlUpdateFailureException {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                for (Map.Entry<String, String> entry : sqlmap.entrySet()) {
                    updateSql(entry.getKey(), entry.getValue());
                }
            }
        })
    }
}
```