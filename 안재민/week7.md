### WEEK 7

## 6.1 트랜잭션 코드의 분리

`UserSevice` 클래스의 메소드에 현재 비즈니스 로직과, 트랜잭션 경계설정 코드가 섞여있다. 
그러나 두 코드들은 서로에게 영향을 주고받지 않는 완전하게 독립된 코드다. 따라서 비즈니스 로직이 트랜잭션의 시작과 종료 사이에서
수행된다는 점만 지키며, 두 코드를 분리해보자

### DI를 이용한 클래스의 분리

현재는 `UserService` 클래스가 클라이언트와 강한 결합도로 고정되어 있다. 따라서 결합도를 느슨하게 하기 위해서
`UserService`를 인터페이스화 시키고, `UserServiceImpl` 에서 이를 구현하도록 바꾸었다.

여기까지만 봤을때는, 그냥 스프링에서 Service를 인터페이스화 시킨 다음, 구현하는 일종의 관례의 느낌으로 받아들였는데,
그 다음 내용을 읽고 서비스를 추상화하는 목적을 알게 되었다

이후 `UserServiceImpl` 클래스에서는 오로지 비즈니스 로직만을 포함시키고, 트랜잭션 경계설정과 관련된 코드는 `UserServiceTx` 라는 `UserService` 인터페이스를 구현하는 새로운 구현체를 하나 더 만들어 여기에서 모두 처리하였다. 그리고 실제 비즈니스 로직을 동작하게 하기 위해, `UserServiceTx` 클래스는 `UserServiceImpl` 클래스를 DI 받아, 자신의 트랜잭션 경계설정 코드 사이에 나머지 모든 기능을 위임하도록 구현하였다.

이를 통해서 

1. 같은 서비스 계층의 코드에서도 관심사를 완벽하게 분리하였다. 
2. 비즈니스 로직에대한 테스트를 손쉽게 만들어낼 수 있다

## 6.2 고립된 단위 테스트

지금의 UserService 테스트는 테스트 대상인 `UserService` 뿐만 아니라, 그 뒤에 존재하는 훨씬 더 많은 오브젝트와, 환경, 서비스, 서버, 심지어
네트워크까지 함께 테스트하는 셈이다. 그 중 하나라도 오류를 발생한다면, `UserService`의 기능 테스트가 실패해버리며, 이는 좋지 못한 테스트이다.

따라서 테스트 대상인 `UserService` 오브젝트를 환경이나 외부서버, 다른 클래스의 코드에 영향을 받지 않도록 고립시키려 한다.

Mock Object를 이용하여, 테스트 대상 이외의 오브젝트들은 테스트를 위한 객체로서의 역할만을 담당한다

이렇게 다른 외부환경에 영향을 받지 않는 단위 테스트를 잘 만드는 것이 중요하다. 단위테스트를 설계할때에는 단위라는 범위를 잘 정하는 것 또한 중요함
단위 테스트와 통합 테스트에 관한 가이드라인

1. 항상 단위 테스트를 먼저 고려한다
2. 비슷한 성격과 목적을 가진 클래스를 모아서, 외부와의 의존관계를 모두 차단하고 테스트를 만든다
3. 외부 리소스를 사용해야만 하는 테스트는 통합 테스트로 만든다
4. DAO와 같이, 단위 테스트로 만들기 어려운 코드도 있다. 이런 경우에는 DB까지 연동하는 테스트로 만드는 편이 효과적이다
5. 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
6. 단위테스트를 만들기 어렵다 판단되는 코드는, 처음부터 통합 테스트를 고려하자, 그러나 통합 테스트에 참여하는 코드 중에서 가능한 많은 부분을 단위테스트로 검증해두는 편이 유리하다
7. 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트이다.

## 6.3 다이내믹 프록시와 팩토리 빈

### 데코레이터 패턴

타켓 클래스에 여러가지 부가기능을 런타임동안 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
동일한 인터페이스를 가진 타깃과, 여러개의 프록시를 이용한다

각 구현체들은 인터페이스를 DI 받으므로, 자신이 동작을 위임하는 클래스가 어떠한 클래스인지 모르기 때문에, 여러개의 프록시를 자유롭게 배치할 수 있다
따라서 클라이언트가 접근하는 방식의 변경 없이 여러가지 부가기능을 추가할 수 있다

### 프록시 패턴

타겟 클래스에 새로운 부가기능을 부여하는 것이 아닌, 클라이언트로 부터의 접근 방식을 제어하기 위해 사용하는 패턴
당장 바로 생성하지 않아도 될 클래스에 대해, 앞단에 프록시를 두어 해당 클래스에 대한 레퍼런스는 클라이언트가 소유하되, 실제 사용될 때 해당 클래스를 프록시에서 생성하는 생성 지연과도 같은 역할을 수행하기도 함

### 다이내믹 프록시

매번 부가기능을 추가할 때마다, 인터페이스를 토대로 구현 코드를 작성하는 일은 매우 번거롭다
따라서 리플렉션 API와 Proxy 클래스를 이용하여, 실행시에 프록시 팩토리에게 인터페이스 정보만 제공하여 얻게된 프록시 오브젝트와 `InvocationHandler` 를 통해 부가기능을 처리한다

`InvocationHandler`에서 리플렉션 API 를 통한 분기로, 여러 함수 호출에 대한 처리를 할 수도 있다

### 다이내믹 프록시를 위한 팩토리 빈

다이내믹 프록시 오브젝트는 Proxy 클래스의 스태틱 팩토리 메소드를 통해서 만들어지기 때문에, 일반적인 스프링의 빈으로 등록할 방법이 없다.

따라서 `FactoryBean` 인터페이스를 상속받아, `getObejct()`  함수를 통해 다이내믹 프록시 오브젝트를 생성하는 방법을 명시하고, 스프링 컨테이너에 팩토리 빈 자체를 빈으로 등록하여 사용하게 된다

### 장점

1. 한번 만들어두면, 여러가지 타겟에 대해 재사용이 가능하다
2. 데코레이터 패턴에서는 각 타겟에 따라 프록시를 생성해야하는 번거로움이 있었다면, 다이내믹 프록시에서는 하나의 핸들러 메소드를 구현함으로써 수많은 메소드에 부가기능을 적용할 수 있다

### 한계

1. 여러개의 클래스에 대한 적용이 어렵다
2. 설정파일이 급격하게 복잡해진다
3. 핸들러 오브젝트가 팩토리 빈 개수만큼 만들어진다. 타겟이 달라질때마다 계속해서 새로운 핸들러 오브젝트를 만들어야함

## 6.4 스프링의 프록시 팩토리 빈

### ProxyFactoryBean

스프링에서는 팩토리 빈 `ProxyFactoryBean`을 이용하여 프록시를 생성하여 빈 오브젝트로 등록할 수 있다
`ProxyFactoryBean` 은 순수하게 프록시 생성만을 담당하고 부가기능은 별도의 빈으로 분리되어 있다

### Advice

`ProxyFactoryBean` 에 부가기능을 제공하는 어드바이스라는 인터페이스를 구현하여 사용할 수 있다

JDK의 다이나믹 프록시와 달리, 메소드 실행 주체인 target 오브젝트로부터 분리되어 있다. 대신에 인자로 들어오는 `MethodInvocation` 을 통해서 메소드를 실행한다. 

따라서 타겟 클래스에서 분리된 채로, 오로지 부가기능에 대한 코드만 집중할 수 있다.

타겟 클래스로부터 분리되어 메소드의 인자를 통해 콜백을 제공받게 되므로, 여러가지 다양한 클래스를 갖는 타겟에 다양하게 적용할 수 있다. 

또한 기존의 핸들러와는 달리, 어드바이스 클래스에서는 템플릿/콜백 패턴을 통해 타겟 클래스에 대한 동작을 수행하므로 무상태하게 클래스를 구현할 수 있다. 따라서 어떠한 부가기능에 대한 어드바이스만을 분리하여 스프링 빈으로 등록하여 싱글톤으로 두고 여러 필요한 곳에서 공유하여 사용할 수 있다

`How`

`MethodInterceptor` 의 `invoke()` 메소드는 팩토리 빈(`ProxyFactoryBean`) 을 통해 타겟 오브젝트에 대한 정보를 제공받기 때문에 템플릿/콜백패턴으로 구현이 가능함

### PointCut

어드바이스를 통해 구현한 부가기능을 적용할 메소드를 판단하는 오브젝트이다. 

JDK의 다이나믹 프록시에서는 부가기능을 적용하는 코드와, 그 코드를 적용할 분기를 나누는 코드가 함께 존재하여, 새로운 메소드가 추가될때마다 ` invokeHandler` 코드의 변경이 두가지 책임에 대해서 변경이 일어났다. 

그러나 스프링에서는 메소드를 선정하는 기능을 분리하여, 어드바이스에서 부가기능을 적용할 메소드인지 판단하는 책임을 덜어내었다. 포인트컷을 `ProxyFactoryBean` 에 적용할 때에는, `Advisor` 형태로 어드바이스와 묶어서 등록해야 한다.

### 정리

기존에 강하게 결합되어 있던 다이나믹 프록시를, 스프링에서는 Advice, Pointcut 으로 각 책임을 분리하고 싱글톤으로 유지될 수 있도록 설계하여서 
각 오브젝트들을 스프링 빈으로 등록하여 사용할 수 있도록 하였다. 이를 통해 각 부가기능에 대한 적용에 있어서 Advice의 재사용성이 높아졌고, 각 오브젝트에서도 자신의 관심사(부가기능의 구현, 메소드의 선정)에만 집중하여 OCP 원칙에도 더욱 부합하는 설계를 할 수 있도록 하였다.
