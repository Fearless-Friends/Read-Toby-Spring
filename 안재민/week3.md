# WEEK 3

## 2장 테스트
스프링이 개발자에게 제공하는 가장 중요한 가치 `객체지향`, `테스트`     
애플리케이션의 입장에서 변화에 대응하는 두가지 전략
1. 확장과 변화를 고려한 객제지향적 설계
2. 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 **_테스트 기술_**

## 2.1 UserDaoTest 다시보기

### 2.1.1 테스트의 유용성

테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서,  
만든 코드를 확신할 수 있게 해주는 작업

### 2.1.2 UserDaoTest의 특징

```java
public class UserDaoTest {
    public static void main(String[] args) throws Exception {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

        UserDao dao = context.getBean("userDao", UserDao.class);

        User user = new User();
        user.setId("user");
        user.setName("백기선");
        user.setPassword("married");

        dao.add(user);

        System.out.println(user.getId() + " 등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());

        System.out.println(user2.getId()+" 조회 성공");
    }
}
```
- 자바에서 가장 손쉽게 실행 가능한 `main()` 메소드 사용
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출
- 테스트에 사용할 입력 값을 직접 코드에서 만들어 넣어준다
- 테스트의 결과를 콘솔에 출력
- 각 단꼐의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다

### 웹을 통한 DAO 테스트의 문제점

DAO, 서비스 계층, MVC 뷰 계층까지 포함한 모든 입출력 기능을 구현한 뒤 테스트
- 너무 많은 컴포넌트들이 한 동작을 테스트하는데 사용되기 때문에, 정확한 원인 규명이 힘들다
- 테스트하고 싶은 DAO 이외에 다른 부분에서의 소요가 많음

### 작은 단위의 테스트

따라서 테스트는 테스트하고자 하는 대상이 명확하다, 그 대상에만 집중해서 테스트하자      
또한 테스트는 가능한 가장 작은 단위로 쪼개서 집중해서 할 수 있어야 한다 `관심사의 분리`     

**_Why_**       
단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.      
이때 확인의 대상과 조건이 간단하고, 명확할수록 좋다.      
가능한 작은 단위로 테스트를 쪼개서 한다면, 한 기능에 대한 오류에 대응할 때에 완전하게 동작하는(테스트 통과) 작은 단위들은 배제해가며,       
보다 적은 비용(시간,노력)을 들여 해결할 수 있기 때문이다.

### 자동수행 테스트 코드

매번 테스트가 필요할 때마다 웹을 띄워서, 폼을 입력하고 작동을 확인하는 작업은 매우 번거롭다.       
따라서 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.      
테스트에 필요한 비용도 감소되고, 미리 잘 짜둔 테스트코드를 이용하여 코드 변경이 있을 때에도 빠르게 완벽하게 동작함을 확인하며 넘어갈 수 있다

### 지속적인 개선과 점진적인 개발을 위한 테스트

테스트 코드는 처음부터 전부 만들어지는 것이 아닌, 작은 기능부터 하나하나 덧붙여 나가며       
기능이 추가될 때마다 테스트도 함께 추가하는 식으로 점진적으로 늘려나간다.

### 2.1.3 UserDaoTest의 문제점

1. 콘솔 화면에 띄워지는 텍스트를 수동 확인해야 하여 번거롭다
2. 실행이 간단한 `main()` 메소드라도, 매번 그것을 실행하는 작업은 번거롭다

## 2.2 UserDaoTest 개선

### 2.2.1 테스트 검증의 자동화

개발과정에서, 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로       
된 자동화된 테스트를 만들자

### 2.2.2 테스트의 효율적인 수행과 결과 관리

**_`main()` 메소드를 사용했을 때 단점_**
- 일정한 패턴의 테스트를 여러개 만드는데 어려움
- 통합적인 테스트를 진행하기에 어려움

### JUnit 테스트로 전환

**_JUnit_**     
테스트 프레임워크, 즉 테스트 코드를 작성하면 프레임워크에 의해 흐름이 제어된다

### 테스트 메소드 전환

기존에 만들었던 테스트 코드는 직접 제어권을 갖는 형태의 코드이기 때문에 적합하지 않다    
따라서 일반 메소드로 전환이 필요하다    

**_JUnit 테스트 메소드 조건_**
1. 메소드는 `public` 으로 선언되어야 한다
2. `@Test` 애노테이션을 붙여야 한다 

### 검증 코드 전환

기존 `if/else` 구문을 통해, 검증하던 구문을 `assertThat` 을 이용하여 변경하였다     
이를 통해 출력값을 따로 두지 않아도, 검증이 완전하게 이루어지면 예외 없이 메소드 호출을 끝내고  
테스트 코드를 성공처리 하게된다.  
만약 기대한 동작과 다르게 동작될 경우, `AssertionError`를 던지고 호출을 종료한다

### JUnit 테스트 실행
```java
class SomeWhere {
    public static void main(String[] args) {
        JUnitCore.main("toby.user.dao.UserDaoTest");
    }
}
```

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

### 포괄적인 테스트

테스트 코드를 작성함에 있어 주로 하는 실수는 성공하는 테스트만 골라서 만드는 것이다.

따라서 테스트를 작성할 때에는 항상 예외적인 상황을 먼저 생각하며 작성하자

### 기능설계를 위한 테스트

***TDD***

"실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"

- 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행되기 때문에 테스트를
  빼먹지 않고 꼼꼼하게 만들어낼 수 있다.

- 테스트를 작성하고 성공시키는 코드를 만드는 주기를 가능한 짧게 가져며, 코드를 확장해나갈 수 있다
- 자연스럽게 단위 테스트를 작성할 수 있다

## 2.4 스프링 테스트 적용

현재의 테스트 코드를 계속해서 사용하게 되면 나타나는 문제점

1. `ApplicationContext` 를 매 메소드 별로 생성하여 사용하기 때문에, 빈이 많아지고 복잡해지면 적지 않은 시간이 걸리게 된다
2. 빈 초기화 과정에서 많은 리소스 또는 독립적인 스레드를 사용하는 경우, 잔여 리소스로 인해 문제가 발생될 수 있다

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

`@RunWith(SpringJUnit4ClassRunner.class)`

JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리해준다

`@AutoWired` 를 통해 AC를 DI 받게 된다

***테스트 메소드의 컨텍스트 공유***

한 클래스에서의 애플리케이션 컨텍스트는 최초로 한번 생성된 이후, 

***테스트 클래스의 컨텍스트 공유***

같은 설정파일을 사용하는, 다른 클래스 사이에서도 최초로 생성된 하나의 애플리케이션 컨텍스트를 공유한다

***@Autowired***

1. Application Context 는 초기화할때 자기 자신도 빈으로 등록하기 때문에 DI 가능하다
2. 단순 빈만이 필요한 경우라면, 빈 자체를 DI 받음으로써 DL 코드를 줄여 단순화 시킬 수 있다
3. 특정 구현 클래스에 해당하는 빈을 가져올 수 있다

### 2.4.2 DI와 테스트

### 테스트 코드에 의한 DI

실행 환경에 따라 의존할 빈을 다르게 설정해야 한다.   
기존의 코드를 유지한채 애플리케이션 컨텍스트에서 강제적으로 빈을 변경하게 되면,  
같은 컨텍스트를 사용하는 다른 클래스에서 문제가 생길 수 있으므로  
`@DirtiesContext` 애노테이션을 붙여 컨텍스트 공유가 되지 않도록 한다.

### 테스트를 위한 별도의 DI 설정

테스트 코드 내에서 수동으로 DI를 하게 되면,
1. 매번 애플리케이션 컨텍스트 생성 비용이 발생
2. 코드의 양이 많아지면 작업이 번거로워짐

따라서 설정파일 자체를 따로 두어 애플리케이션 컨텍스트를 생성하도록 한다

### 컨테이너 없는 DI 테스트

애플리케이션 컨텍스트를 생성하는 것은, 테스트 할 오브젝트 이외의 다른 여러 오브젝트를  
생성하는 작업이 동반되기 때문에, 불필요하게 애플리케이션 컨텍스트를 생성하는 작업 대신
- 직접 코드상에서 DI를 해주는 방식

으로 변경하였다.

### DI를 이용한 테스트 방법 선택

1. 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자  
2. 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트할 경우에는 스프링 설정을 이용하는 방법이 좋다  
3. 예외적인 의존관계를 설정해야하는 경우에는 컨텍스트 공유에 신경써서 작성하자 `@DirtiesContext`

## 2.5 학습 테스트로 배우는 스프링

테스트 코드를 애플리케이션 검증이 아닌, 새로운 API나 프레임워크의 기능을 테스트를 통해 사용 방법을 익힐 수 있다

**_버그 테스트_**
1. 테스트의 완성도를 높여준다
2. 버그의 내용을 명확하게 분석하게 해준다
3. 기술적인 문제를 해결하는 데 도움이 된다

**_주요 테스트 기법_**
- 동등 분할
  - 같은 결과를 내는 값의 범위를 구해서 각 대표 값으로 테스트 하는 방법
- 경계값 분석
  - 에러는 동등분할의 경계에서 주로 많이 발생한다는 특징을 이용하여, 경계의 근처에 있는 값을 이용해 테스트 하는 방법