# WEEK 4

## 3장 템플릿

## 3.1 다시 보는 초난감 DAO

### 3.1.1 예외처리 기능을 갖춘 DAO

기존 dao 코드에서는 공유 리소스를 정상적으로 반환하지 않을 수 있는 위험이 있다      
따라서 예외처리를 통해 어떠한 상황에서도 리소스를 반환하도록 리팩토링 함

- 리소스는 받아오는 순서 반대로 반환시켜주자

## 3.2 변하는 것과 변하지 않는 것

### 3.2.1 JDBC try/catch/finally 코드의 문제점

만약 리소스를 사용하는 메소드가 수천개가 있다고 한다면, 리소스의 사용에 있어 오류가 발생했을 때      
모든 메소드의 코드를 살펴봐야하는 끔찍한 일을 해야할 수도 있음

### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

**_1. 메소드 추출_**

메소드마다 달라지는 부분을 메소드로 추출하여, 메소드에 재사용성을 높임     
기존 달라지던 부분의 구현을 추출한 메소드의 구현부에 두어, 컨텍스트와 관련된 로직의 흐름은 모든  
클라이언트에 동일하게 적용할 수 있게 되었음

그러나, 모순으로 추출한 메소드는 다른 클래스에서 재사용이 불가함

**_2. 템플릿 메소드 패턴의 적용_**

기존의 추출했던 메소드를 상위 클래스에 추상 메소드로 두어, 구현 클래스에 따라 오버라이딩하여 사용하도록 리팩토링     

그러나 OCP 원칙은 잘 지키게 설계되었지만, 각 기능(add,find,delete)이 추가될 때마다 클래스를 계속 생성해야함

**_3. 전략 패턴의 적용_**

변화하는 컨텍스트의 기능을, 인터페이스로 분리하고 실제 로직에서는 인터페이스의 메소드를 호출한다   

그러나 인터페이스의 구체 클래스를 dao 클래스에서 정하기 때문에 OCP 위배

**_DI 적용을 위한 클라이언트/컨텍스트 분리_**

따라서 인터페이스의 구체 클래스를 정하는 일 (의존성 연결)을 외부에 위임하자        
외부라는 관점은 외부 클래스나, 클라이언트가 아닌 다른 메소드에게 위임하는 것도 포함한다       
> **_마이크로 DI_**     
> DI의 장점을 단순화하여, IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI 라고 한다

## 3.3 JDBC 전략 패턴의 초기화
**_문제점_**
- 새로운 메소드가 생길 때마다, 새로운 클래스 파일을 계속해서 생성해야한다

따라서 전략에대한 구현 클래스를 **_로컬 클래스_** 로 변경해 메소드 안에서만 사용 가능하도록 변경  
- 그렇다면, 일회성 클래스를 굳이 클래스 이름을 지녀야 할까? 

따라서 로컬 클래스가 아닌, 파라미터 단에서 **_익명 내부 클래스_** 로 구현

## 3.4 컨텍스트와 DI

### 3.4.1 JdbcContext의 분리

Jdbc 와 관련된 관심사(Context)는 UserDao 가 아닌 다른 Dao 에서도 사용  
따라서 이를 클래스로 분리하여, 다른 Dao에서도 사용 가능하도록 리팩토링 한다  


### 3.4.2 JdbcContext의 특별한 DI

JdbcContext와 Dao 클래스를 DI 구조로 만드는 이유     
**_Why_**
1. 싱글톤 빈으로 유지되어, 스프링 컨테이너 안에서 공유되어 사용되는 편이 이상적임
2. JdbcContext 또한 다른 클래스에 의존하고 있음

그렇다면 너무 긴밀한 결합을 유지하는 것이 아닐까?
- 두 클래스(Dao,JdbcContext)는 강한 응집도를 가짐
- UserDao 가 JDBC가 아닌, 다른 ORM으로 변경될 경우 Jdbc 또한 통째로 바뀌어야함
- 변경의 시점이 동일해서, 그냥 결합을 강하게 하고 DI의 장점을 취하는 형태로 구

**_코드를 이용하는 수동 DI_**

위의 두 클래스같이, 강한 응집도를 같는 경우 외부에서 빈을 만들어주지 않고,  
그냥 UserDao 에서 JdbcContext 를 직접 만들고 사용하도록 구현해도 됨
- 싱글톤이 아니더라도, Dao 마다 컨텍스트를 가지고 있어도 메모리에 주는 부담이 크게 없음
  - Context 클래스는 지닌 state가 크게 없기 때문
- 종속 관계를 외부로부터 감출 수 있음(설정파일이 아닌, 코드 단에서 직접 구현되어서)

## 3.5 템플릿과 콜백

### 3.5.1 템플릿/콜백의 동작원리



## 3.6 스프링의 JdbcTemplate

### 3.6.1 update()

### 3.6.2 queryForInt()

### 3.6.3 queryForObject()

### 3.6.4 query()

**_기능 정의와 테스트 작성_**

**_query() 템플릿을 이용하는 getAll() 구현_**

**_테스트 보완_**

### 3.6.5 재사용 가능한 콜백의 분리

**_DI를 위한 코드 정리_**

**_중복 제거_**

**_템플릿/콜백 패턴과 UserDao_**